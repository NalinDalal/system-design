
# Notification System

Users receive notifications either in-app or via email when events happen in the application.

Example scenario (synchronous flow):

1. Client: POST /signup with payload `{email, password}`
2. Server: creates user record in the database
3. Server: calls `sendEmail()` which invokes an external provider (e.g., Gmail API)
4. Server: returns response to client

Problems with the synchronous approach:

- High latency: external provider calls can add several seconds to request latency.
- Poor availability: if the provider is down or rate-limited the request can fail.
- Scalability: bursts of requests can exceed provider rate limits.

Example: if 100 users hit `/signup` and the provider allows 30 req/s, 70 requests may be dropped or delayed.

Make it asynchronous:

- On signup, persist the user and enqueue an email task instead of calling the provider synchronously.
- A background worker consumes the queue and sends emails to the provider.
- The signup route returns quickly; email delivery is retried by the worker if it fails.

Benefits:

- Fast responses for users.
- Resilience to provider throttling via rate limiting and retries.
- Better scalability and observability.

```mermaid
flowchart LR
    subgraph Users
        U1((User))
        U2((User))
        U3((User))
    end

    U1 --> S["POST /signup - fname, lname, email"]
    U2 --> S
    U3 --> S

    S --> DB[(Database)]
    S -->|Enqueue: sendReqToQueue| Q[Queue]

    S --> R[Response]

    Q -->|1000| RL[Rate Limiting]
    RL --> W1["Email Worker - 2s"]
    RL --> W2["Email Worker - 2s"]

    W1 --> M["Mail Service - 30m/s (use 25m/s)"]
    W2 --> M
```

- Fast response to user. 
- Provider throttling handled via queue + rate limiter.


## Production architecture

In production, clients communicate with a load balancer which distributes traffic to application servers. Signup and other user events enqueue messages to a broker (e.g., SQS, Kafka) that are consumed by workers.

Common components:

- Load Balancer
- Application servers
- Message Broker / Queue (SQS, Kafka)
- Worker instances (EC2, containers)
- External providers (SES, Firebase, Push services)

Example flow:

- Clients -> Load Balancer -> Application Server
- Application Server enqueues an event to the broker
- Worker consumes the event and calls the external provider (SES)

Retry strategy and failure handling:

1. Use retries with exponential backoff (e.g., 0s, 1s, 2s, 4s, 8s) up to a configurable `max_retry`.
2. If `max_retry` is exceeded, move the message to a Dead Letter Queue (DLQ) for manual inspection and reprocessing.

This avoids infinite retry loops and preserves failed events for developers to investigate.

As the system grows, separate queues may be introduced for different event types (email, in-app, push). Each queue gets its own workers and DLQ.

Example API mapping changes:

```
POST /login        -> sendToEmailQueue
POST /post         -> sendToInAppQueue
POST /friend-req   -> sendToPushQueue
```

Keep queues decoupled to reduce coupling between services. However, more queues increases operational surface area.

```mermaid
flowchart LR
    %% Clients
    subgraph Clients
        U1((User))
        U2((User))
        U3((User))
    end

    %% Entry Point (Message Broker)
    Broker[(Message Broker)]

    U1 --> Broker
    U2 --> Broker
    U3 --> Broker

    %% Queues
    EQ["Email Queue"]
    IAQ["In App Queue"]
    PNQ["Push Notification Queue"]

    %% Workers
    EW["Email Worker"]
    IAW["In App Worker"]
    PNW["Push Notification Worker"]

    %% DLQ
    DLQ["DLQ (Max Retry = 10)"]

    %% Flows
    Broker --> EQ
    Broker --> IAQ
    Broker --> PNQ

    EQ --> EW
    EW -->|Fail| DLQ
    EQ -->|Retry 1 Day| EW

    IAQ --> IAW
    PNQ --> PNW

    %% Services
    SES["Email Service"]
    DB[(Database)]
    Push[(Push Service)]

    EW --> SES
    IAW --> DB
    PNW --> Push

    %% API mapping
    subgraph API Calls
        A1["POST /login - sendToEmailQueue"]
        A2["POST /post - sendToInAppQueue"]
        A3["POST /friend-req - sendToPushQueue"]
    end

    A1 --> EQ
    A2 --> IAQ
    A3 --> PNQ
```

---

we move to event driven architecture

we decouple the servers

we raise events, and then workers listen to it

make an announcement, anyone who is relevant to it, will listen to it
rather than telling everyone individually

pub-sub/fan-out architecture

we decouple the system,
now whatever actions/events happens we trigger a sms

bind this sms to queue

now it changes to

```
POST /post
sendEventToSNS

POST /friend-req
sendEventToSNS
```

```mermaid
flowchart LR
    %% Clients
    subgraph Clients
        U1((User))
        U2((User))
        U3((User))
    end

    %% Entry Point (Message Broker)
    Broker[(Message Broker)]
    U1 --> Broker
    U2 --> Broker
    U3 --> Broker

    %% Queues
    EQ[Email Queue]
    IAQ[In App Queue]
    PNQ[Push Notification Queue]

    %% Workers
    EW[Email Worker]
    IAW[In App Worker]
    PNW[Push Notification Worker]

    %% DLQ
    DLQ[[DLQ]]
    NoteDLQ["Max Retries = 10"]

    %% Flows
    Broker -->|user.signup / user.login| EQ
    Broker -->|user.post / user.login| IAQ
    Broker -->|user.send_req| PNQ

    EQ --> EW
    EW -->|Fail| DLQ
    EW -.-> NoteDLQ
    IAQ --> IAW
    PNQ --> PNW

    %% Services
    SES[Email Service]
    DB[(Database)]
    Push[(Push Service)]

    EW --> SES
    IAW --> DB
    PNW --> Push

    %% API Calls
    subgraph API Calls
        A1["POST /signup, /login"]
        A2["POST /post"]
        A3["POST /send_req"]
    end

    A1 --> EQ
    A2 --> IAQ
    A3 --> PNQ

```

you can use some service - [Novu- open souce](https://novu.co/) ,

a use case of slack:

```mermaid
flowchart TD
    %% Styles
    classDef pref fill:#d5e3ff,stroke:#000,stroke-width:1px
    classDef prefVal fill:#fff2cc,stroke:#000,stroke-width:1px
    classDef user fill:#e6ccff,stroke:#000,stroke-width:1px
    classDef parsing fill:#ffebcc,stroke:#000,stroke-width:1px
    classDef yes fill:#ccffcc,stroke:#000,stroke-width:1px
    classDef no fill:#ffcccc,stroke:#000,stroke-width:1px

    %% Start
    A([Should we send a notification?]):::user

    A -->|No| N1((NO)):::no
    A -->|Yes| B1["Thread message && User subscribed?"]:::parsing

    %% Left side branch
    B1 -->|No| B2["Channel muted?"]:::user
    B1 -->|Yes| C1["User in DnD?"]:::user

    B2 -->|Yes| N1
    B2 -->|No| C1

    C1 -->|Yes| C2["DnD Override?"]:::pref
    C1 -->|No| D1["@channel/@everyone/@here message?"]:::parsing

    C2 -->|No| N1
    C2 -->|Yes| D1

    D1 -->|Yes| D2["@channel mentions suppressed?"]:::pref
    D1 -->|No| E1["Channel notification pref is 'Nothing'"]:::prefVal

    D2 -->|Yes| E1
    D2 -->|No| YES1((YES)):::yes

    E1 -->|Yes| N1
    E1 -->|No| E2["thread_everything pref on?"]:::prefVal

    E2 -->|Yes| YES1
    E2 -->|No| E3["Thread message && User subscribed?"]:::parsing

    E3 -->|Yes| YES1
    E3 -->|No| F1["What is the user’s channel notification pref for this device?"]:::pref

    %% Channel Pref branches
    F1 --> F2a["Nothing"]:::prefVal
    F1 --> F2b["Everything"]:::prefVal
    F1 --> F2c["Mentions"]:::prefVal
    F1 --> F2d["Default"]:::prefVal

    F2a --> N1
    F2b --> YES1

    F2c --> G1["Thread message?"]:::parsing
    G1 -->|Yes| G2["User subscribed?"]:::user
    G1 -->|No| G3["DM?"]:::parsing

    G2 -->|Yes| YES1
    G2 -->|No| N1

    G3 -->|Yes| YES1
    G3 -->|No| G4["@mention?"]:::parsing

    G4 -->|Yes| YES1
    G4 -->|No| G5["Comment on file owned by user (desktop)"]:::user
    G5 -->|Yes| YES1
    G5 -->|No| N1

    F2d --> H1["What is the user’s global notification pref for this device?"]:::pref
    H1 --> H2a["Mentions"]:::prefVal
    H1 --> H2b["DMs (mobile)"]:::prefVal
    H1 --> H2c["Highlight Words (mobile)"]:::prefVal
    H1 --> H2d["All"]:::prefVal
    H1 --> H2e["Never"]:::prefVal

    H2e --> N1

    H2a --> G1
    H2b --> G3
    H2c --> G4

    H2d --> J1["Thread message?"]:::parsing
    J1 -->|Yes| J2["User subscribed?"]:::user
    J1 -->|No| J3["@here"]:::parsing

    J2 -->|Yes| YES1
    J2 -->|No| N1

    J3 -->|Yes| YES1
    J3 -->|No| J4["Highlight word?"]:::parsing
    J4 -->|Yes| YES1
    J4 -->|No| J5["User presence active?"]:::user

    J5 -->|No| YES1
    J5 -->|Yes| J6["Thread message?"]:::parsing
    J6 -->|Yes| J7["User subscribed?"]:::user
    J6 -->|No| N1
    J7 -->|Yes| YES1
    J7 -->|No| N1

    %% Success branch
    YES1 --> M1["Mobile?"]:::user
    M1 -->|Yes| M2["Past mobile push timing threshold?"]:::user
    M2 -->|Yes| YES2((YES)):::yes
    M2 -->|No| N1
    M1 -->|No| YES2

    %% End states
    N1:::no
    YES2:::yes
```

[next-js-simulator](https://github.com/NalinDalal/notification-system-smulator)

[bun](https://github.com/NalinDalal/notification-system-bun)

---

# Reliability & Features

- Caching: contact info & templates.
- Rate limiting: avoid spam + respect provider caps.
- Preferences: per-user DND/mute.
- Templates: reusable messages with placeholders.
- Fallback providers: if Twilio fails, use backup.
- Monitoring: queue depth, latency, error rate.

---

[1] [Twilio SMS](https://www.twilio.com/sms)

[2] [Nexmo SMS](https://www.nexmo.com/products/sms)

[3] [Sendgrid](https://sendgrid.com/)

[4] [Mailchimp](https://mailchimp.com/)

[5] [You Cannot Have Exactly-Once Delivery](https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/)

[6] [Security in Push Notifications](https://cloud.ibm.com/docs/services/mobilepush?topic=mobile-pushnotification-security-in-push-notifications)

[7] [RadditMQ](https://bit.ly/2sotIa6)