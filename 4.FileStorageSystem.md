# File Storage System

## Overview

This document compares traditional file storage (hierarchical filesystems) with object storage (flat, ID-addressable objects). It outlines their characteristics, pros/cons, and when to choose each.

## File Storage

File storage uses a hierarchical namespace (directories and files) backed by block-based storage on disks. It is the classic approach used by operating systems.

Examples: NTFS, FAT32, ext4, NFS, SMB

### Advantages

- Familiar and intuitive model for users and applications
- Granular permissions and POSIX semantics
- Efficient for many small files and low-latency operations

### Disadvantages

- Scalability limitations for very large datasets or massive parallel access
- Limited built-in metadata compared to object stores
- Can be complex to manage for large, distributed systems

## Object Storage

Object storage stores data as discrete objects consisting of the data blob, a unique identifier, and extensive metadata. Objects are stored in a flat address space and retrieved by ID.

Example object (JSON-like):

```json
{
    "object_id": "123abc",
    "data": "<binary>",
    "metadata": {
        "title": "sample_video",
        "format": "mp4",
        "resolution": "1080p",
        "duration": 120
    }
}
```

Objects are kept in a storage pool (flat namespace) and addressed by their IDs:

```
01
02
03
...
NI
```

Examples: AWS S3, Google Cloud Storage, Azure Blob Storage

### Pros

- Highly scalable and designed for massive data volumes
- Rich, flexible metadata per object
- Cost-effective for large unstructured datasets

### Cons

- Less suitable for workloads that require POSIX file semantics
- No native hierarchical file structure (can be emulated via prefixes)
- Potentially higher latency for some fine-grained operations

## When to Use Which

| File Storage                      | Object Storage                     |
|-----------------------------------|-------------------------------------|
| Need hierarchical directory tree  | Handling very large datasets        |
| Many small files / low latency    | Need rich per-object metadata       |
| POSIX semantics / granular perms  | Optimized for scalability and cost  |

## Real-World Examples

- Company shared drives and home directories → File Storage
- Cloud media storage, backups, archives → Object Storage

Sample object IDs:

- `vid123abc`
- `image456def`
- `audio_123`

Common metadata fields:

- Title, Format, Resolution, Duration, Tags, Creator

[Sample code and reference implementation](https://github.com/NalinDalal/file-storage-rust)